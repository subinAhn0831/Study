**java.lang**

- 자바의 기본 라이브러리
- 래퍼클래스, System, Object 등이 있음
- 클래스에 import 문을 쓰지 않아도 자동으로 import 됨

**Object class**

- 자바 모든 클래스의 최상위 클래스
- 부모클래스를 상속받지 않는 클래스들은 자동으로 Object 클래스를 상속받음
- 그래서 클래스의 부모, 부모로 올라가다 보면  최상위는 무조건 Object 클래스임
- 객체 인스턴스가 생성될 때, 한 메모리에 상속중인 클래스도 같이 할당됨(→Object class가 무조건 할당되는것)
- 다형적 참조 가능
    - Object는 모든 객체를 담을 수 있는 클래스이기 때문에 다양한 클래스 객체를 함께 담을 수 있음
    - ex) 하나의 Object 배열에 address class, student class, teacher class 를 같이 담을 수 있음
- 메소드 오버라이딩 활용 불가
    - 각 객체의 기능 활용을 위해서는 다운캐스팅을 해야 함
        
        ex)
        
        ```java
        Dog dog = new Dog();  
        if(obj instance if Dog dog) dog.bark();
        ```
        
자바에서 메소드를 찾을 때, 자식에서부터 먼저 찾으면서 부모로 올라감 → 자식에 오버라이딩 되어있는 메소드가 있을 경우 자식꺼가 출력됨!

**toString()**

- 객체의 인스턴스 정보, 참조값
    
    → 이 값으로는 객체안에 어떤 값이 들어있는지 모름
    
    → 그래서 보통은 toString()을 재정의(오버라이딩) 해서 사용함

**다형성을 잘 활용한다 == 다형적 참조와, 메서드 오버라이딩을 적절하게 사용한다!**

**항상 오버라이딩 된 메소드가 먼저 참조된다.**

→ System.out.println(Object obj) 가 그 예임

**OCP원칙**

- open : 새로운 클래스를 추가하고, 오버라이딩해서 기능을 확장할 수 있다.(toString())
- close :  새로운 클래스를 추가해도, object, toString()을 사용하는 클라이언트 클래스를 변경할 필요가 없다.

**자바언어는 객체지향 언어답게 언어 스스로도 객체지향의 특징을 매우 잘 활용한다!**

### **equals()**

- 동일성과 동등성
- 동일성 → 두 객체의 참조가 동일한 객체를 가리키는지 (==)
- 동등성 → 두 객체가 논리적으로 동등한지 (equals() 메소드 사용)
- Object 클래스의 equals() 메소드는 동일성 비교로 구현되어있음 (==으로)
- 동등성이라는 개념은 객체마다 다름. 동등성 비교를 사용하고 싶으면 equals()를 재정의해서 사용하면 됨! > ide에서 generate로 자동 생성 가능
- equals() 메소드 구현 규칙

```
반사성(Reflexivity): 객체는 자기 자신과 동등해야 한다. ( x.equals(x) 는 항상 true ).
대칭성(Symmetry): 두 객체가 서로에 대해 동일하다고 판단하면, 이는 양방향으로 동일해야 한다.
( x.equals(y) 가 true 이면 y.equals(x) 도 true ).
추이성(Transitivity): 만약 한 객체가 두 번째 객체와 동일하고, 두 번째 객체가 세 번째 객체와
동일하다면, 첫번째 객체는 세 번째 객체와도 동일해야 한다.
일관성(Consistency): 두 객체의 상태가 변경되지 않는 한, equals() 메소드는 항상 동일한 값을
반환해야 한다.
null에 대한 비교: 모든 객체는 null 과 비교했을 때 false 를 반환해야 한다.
```

## 불변객체

### 기본형과 참조형

- 자바의 데이터 타입 종류
- 기본형 : 하나의 값을 절대로 공유하지 않음
    - 복사 시에, 값이 복사됨 → 대입 변수와 복사 대상 변수가 별도로 존재
- 참조형 : 하나의 객체를 참조값을 통해 여러 변수가 공유 가능
    - 복사 시에 참조값(주소)가 복사됨 → 대입변수와 복사대상이 같은 참조값을 바라봄

- 불변객체
    - 불변이라는 단순한 제약을 통해 사이드이펙트를 막을 수 있음!
    - 필드를 수정하지 못하도록 final로 선언해주면 ok

      —>이렇게 하면 값의 변경 자체를 막기 때문에 사이드이펙트 예방 가능

    - 또는, 수정된 값을 가진 새로운 객체 반환하는 메서드 생성해서, 아예 새로운 객체로 return 해주기

---

## String 클래스

- String 클래스 내부적으로 byte[] 배열로 바뀜
- 리터럴로  선언 시, 자동으로 java에서 String 인스턴스 생성해줌
- 비교는 equals()로  해야함 , == 비교 시, 참조값 비교가 됨
- 자바는 내부적으로 문자열 풀이 있음

  **풀(pool)은 자원이 모여있는 곳을 의미**

    - 문자열 리터럴을 사용하는 경우, 자바는 메모리 효율성과 성능 최적화를 위해 문자열 풀을 사용
    - 자바가 실행되는 시점에 클래스 문자열 리터럴이 있으면 문자열 풀에 미리 String 인스턴스를 생성해 둠
    - 문자열 리터럴이 실행 될 때, 문자열 풀에서 똑같은 문자를 가진 인스턴스가 있는지 찾은 후, 같은 문자가 있는 인스턴스가 있다면 해당 인스턴스를 반환

      —> 그래서 리터럴로 선언 시, == 비교하면 true가 나오는 경우가 있음
    - String 클래스는 불변객체
      - 불변인 String은 내부 값을 변경할 수 없어서 변경된 값을 기반으로 새로운 String 객체를 생성함
      - 새로운 객체를 생성하면 변경 시, 변경 과정에서 생성된 인스턴스들은 GC 대상이 됨

  ### StringBuilder

    - 가변 String
    - 내부의 값을 변경하기 때문에 새로운 객체를 생성 x

      → 성능, 메모리에 더 효율적


    → 실제로는 문자열을 다룰 때, 자바 자체적으로 최적화를 해줌! 그래서 그냥 + 연산으로 쓰면 됨
    
    - StringBuilder를 직접 사용하는 것이 더 좋은 경우
        - 반복문에서 반복해서 문자를 연결할 때
        - 조건문을 통해 동적으로 문자열을 조합할 때
        - 복잡한 문자열의 특정 부분을 변경해야 할 때
        - 매우 긴 대용량 문자열을 다룰 때